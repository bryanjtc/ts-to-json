import{$ as ar,$a as ao,A as P,Aa as zr,Ab as Bo,B as v,Ba as Br,Bb as Po,C,Ca as Pr,Cb as vo,D as c,Da as vr,Db as Co,E as u,Ea as Cr,Eb as Go,F as G,Fa as Gr,Fb as Ho,G as H,Ga as Hr,Gb as Io,H as I,Ha as Ir,Hb as Jo,I as J,Ia as Jr,Ib as Mo,J as M,Ja as Mr,Jb as Qo,K as Q,Ka as Qr,Kb as Ro,L as R,La as Rr,Lb as Wo,M as W,Ma as Wr,Mb as Xo,N as X,Na as Xr,Nb as Yo,O as Y,Oa as Yr,Ob as Zo,P as Z,Pa as Zr,Pb as _o,Q as _,Qa as _r,Qb as Uo,R as U,Ra as Ur,Rb as Lo,S as L,Sa as Lr,Sb as rt,T as rr,Ta as ro,Tb as ot,U as or,Ua as oo,Ub as tt,V as tr,Va as to,Vb as et,W as er,Wa as eo,X as pr,Xa as po,Y as mr,Ya as mo,Z as xr,Za as xo,_ as fr,_a as fo,a as p,aa as nr,ab as no,ba as ir,bb as io,ca as sr,cb as so,da as cr,db as co,e as g,ea as ur,eb as uo,f as N,fa as yr,fb as yo,g as b,ga as lr,gb as lo,h,ha as Tr,hb as To,i as K,ia as wr,ib as wo,j as k,ja as gr,jb as go,k as D,ka as Nr,kb as No,l as d,la as br,lb as bo,m as n,ma as hr,mb as ho,n as E,na as Kr,nb as Ko,o as i,oa as kr,ob as ko,p as F,pa as Dr,pb as Do,q as S,qa as dr,qb as Eo,r as j,ra as Er,rb as Fo,s as A,sa as Fr,sb as So,t as $,ta as Sr,tb as jo,u as q,ua as jr,ub as Ao,v as O,va as Ar,vb as $o,w as V,wa as $r,wb as qo,x as z,xa as qr,xb as Oo,y as B,ya as Or,yb as Vo,z as s,za as Vr,zb as zo}from"./chunk-VXFIAAAN.mjs";import o from"typescript";var f=class{constructor(r){this.childNodeParser=r}supportsNode(r){return r.kind===o.SyntaxKind.FunctionDeclaration?Boolean(r.name):(r.kind===o.SyntaxKind.ArrowFunction||r.kind===o.SyntaxKind.FunctionExpression)&&o.isVariableDeclaration(r.parent)}createType(r,t){let e=r.parameters.map(m=>this.childNodeParser.createType(m,t)),l=new u(`object-${n(r,t)}`,[],e.map((m,x)=>{let T=r.parameters[x].questionToken?!1:!r.parameters[x].initializer;return new c(r.parameters[x].name.getText(),m,T)}),!1);return new i(this.getTypeName(r,t),l)}getTypeName(r,t){if(o.isArrowFunction(r)||o.isFunctionExpression(r)){let e=r.parent;if(o.isVariableDeclaration(e))return`NamedParameters<typeof ${e.name.getText()}>`}if(o.isFunctionDeclaration(r))return`NamedParameters<typeof ${r.name.getText()}>`;throw new Error("Expected to find a name for function but couldn't")}};p(f,"FunctionParser");import w from"typescript";var a=class{supportsNode(r){return r.kind===w.SyntaxKind.UndefinedKeyword}createType(r,t){return new s}};p(a,"UndefinedLiteralNodeParser");export{D as AliasType,Ar as AliasTypeFormatter,fo as AnnotatedNodeParser,E as AnnotatedType,qr as AnnotatedTypeFormatter,V as AnyType,Or as AnyTypeFormatter,ao as AnyTypeNodeParser,no as ArrayLiteralExpressionNodeParser,io as ArrayNodeParser,z as ArrayType,Vr as ArrayTypeFormatter,so as AsExpressionNodeParser,g as BaseError,k as BaseType,Er as BasicAnnotationsReader,co as BooleanLiteralNodeParser,Z as BooleanType,zr as BooleanTypeFormatter,uo as BooleanTypeNodeParser,yo as CallExpressionParser,eo as ChainNodeParser,Sr as ChainTypeFormatter,xo as CircularReferenceNodeParser,jr as CircularReferenceTypeFormatter,lo as ConditionalTypeNodeParser,to as Context,Nr as DEFAULT_CONFIG,i as DefinitionType,Br as DefinitionTypeFormatter,N as DiagnosticError,To as EnumNodeParser,P as EnumType,Pr as EnumTypeFormatter,po as ExposeNodeParser,wo as ExpressionWithTypeArgumentsNodeParser,Fr as ExtendedAnnotationsReader,go as FunctionNodeParser,Kr as FunctionParameter,f as FunctionParser,kr as FunctionType,No as HiddenNodeParser,bo as IndexedAccessTypeNodeParser,ho as InterfaceAndClassNodeParser,nr as IntersectionNodeParser,v as IntersectionType,vr as IntersectionTypeFormatter,ko as IntrinsicNodeParser,Do as LiteralNodeParser,O as LiteralType,Cr as LiteralTypeFormatter,Gr as LiteralUnionTypeFormatter,yr as LogicError,Eo as MappedTypeNodeParser,M as NeverType,Hr as NeverTypeFormatter,Fo as NeverTypeNodeParser,lr as NoRootNamesError,Tr as NoRootTypeError,wr as NoTSConfigError,So as NullLiteralNodeParser,s as NullType,Ir as NullTypeFormatter,jo as NumberLiteralNodeParser,Y as NumberType,Jr as NumberTypeFormatter,Ao as NumberTypeNodeParser,$o as ObjectLiteralExpressionNodeParser,c as ObjectProperty,u as ObjectType,Mr as ObjectTypeFormatter,qo as ObjectTypeNodeParser,G as OptionalType,Qr as OptionalTypeFormatter,Oo as OptionalTypeNodeParser,Vo as ParameterParser,zo as ParenthesizedNodeParser,Bo as PrefixUnaryExpressionNodeParser,B as PrimitiveType,Rr as PrimitiveUnionTypeFormatter,Po as PropertyAccessExpressionParser,F as ReferenceType,Wr as ReferenceTypeFormatter,Dr as RestType,Xr as RestTypeFormatter,vo as RestTypeNodeParser,Lo as SchemaGenerator,Co as StringLiteralNodeParser,Go as StringTemplateLiteralNodeParser,X as StringType,Yr as StringTypeFormatter,Ho as StringTypeNodeParser,dr as SymbolType,Zr as SymbolTypeFormatter,Io as SymbolTypeNodeParser,mo as TopRefNodeParser,Jo as TupleNodeParser,H as TupleType,_r as TupleTypeFormatter,Mo as TypeAliasNodeParser,Qo as TypeLiteralNodeParser,Wo as TypeOperatorNodeParser,Xo as TypeReferenceNodeParser,Ro as TypeofNodeParser,a as UndefinedLiteralNodeParser,I as UndefinedType,Ur as UndefinedTypeFormatter,Yo as UndefinedTypeNodeParser,Zo as UnionNodeParser,Q as UnionType,Lr as UnionTypeFormatter,$ as UnknownNodeError,R as UnknownType,gr as UnknownTypeError,ro as UnknownTypeFormatter,_o as UnknownTypeNodeParser,W as VoidType,oo as VoidTypeFormatter,Uo as VoidTypeNodeParser,rt as createFormatter,et as createGenerator,ot as createParser,tt as createProgram,K as deepMerge,j as derefAnnotatedType,S as derefType,br as extractLiterals,q as formatError,A as getAllOfDefinitionReducer,n as getKey,cr as getTypeByKey,sr as getTypeKeys,rr as hasJsDocTag,tr as hasModifier,d as hash,h as intersectionOfArrays,Ko as intrinsicMethods,_ as isAssignableTo,or as isNodeHidden,er as isPublic,pr as isStatic,L as localSymbolAtNode,$r as makeNullable,mr as narrowType,xr as notUndefined,fr as preserveAnnotation,ar as removeUndefined,hr as removeUnreachable,C as strip,U as symbolAtNode,ir as translate,ur as typeName,b as uniqueArray,J as uniqueTypeArray};
